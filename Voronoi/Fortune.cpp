#pragma once
#include "Fortune.h"
#include <fstream>
#include <string>


void executeCircleEvent(RBTree& beachfront, voronoiEvent currEvent) {

}

void executeSiteEvent(RBTree& beachfront, voronoiEvent currEvent) {
	// If this is the first site event, then there's not much to process. The first site will simply form the whole beachline tree.
		beachfront.insert(currEvent.getX(), currEvent.getY());
		std::ofstream orderTracker("eventOrder.txt", std::ofstream::app);
		orderTracker << "Site event with siteX << " << currEvent.getX() << " >> added." << std::endl;


	// If the beachfront is not empty, then the existing beachfront will be altered.
	// Step 1: Find the arc (alpha) vertically above the new site (Pi).
	//			- If the node (Pj) representing alpha has a pointer to a circle event in the queue, then this event can be deleted (as it is a false alarm)
	// Step 2: Replace the leaf representing alpha with a subtree with three leaves:
	//			- The middle leaf stores Pi.
	//			- The left leaf stores Pj, and the right leaf also stores Pj.
	//			- The internal nodes store the tuples <Pj, Pi> and <Pi, Pj>
	//				- These two represent the two breakpoints in the beachfront generated by the introduction of the new site
	//					- The introduction of a new site splits the above arc into two chunks, after all.
	//			- Check whether the overall tree needs rebalancing.
	//				- There is essentially a whole new tree inserted here. Should all of the new nodes/leaves be made red here?
	//					- TODO: Try this on paper!
	// Step 3: Create two half-edges separating V(Pi) and V(Pj), which are based on the two breakpoints generate by the pairs <Pj, Pi> and <Pi, Pj>
	// Step 4: Check whether Pi and its two left neighbours are not collinear and can generate a circle.
	//			- Also check whether Pi and its two right neighbours are not collinear and can generate a circle.
	//			- Note: If the site event generates a circle event that is triggered at the same y, then that's no problem:
	//				- Inserting the circle event into the min-heap will put it at the very top, so that the sweepline doesn't have to move before processing it.
	//
	//
	//
	//
}

void addCircleEvent() {

}

void removeCircleEvent() {

}